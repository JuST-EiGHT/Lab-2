# Отчет по лабораторной работе № 2

#### № группы: `ПМ-2505`

#### Выполнил: `Шаврин Радимир Вячеславович`

#### Вариант: `21`

### Cодержание:

- [Задание 1](#задание-1)
  - [1.1 Постановка задачи](#11-постановка-задачи)
  - [1.2 Входные и выходные данные](#12-входные-и-выходные-данные)
  - [1.3 Выбор структуры данных](#13-выбор-структуры-данных)
  - [1.4 Алгоритм](#14-алгоритм)
  - [1.5 Программа](#15-программа)
  - [1.6 Анализ правильности решения](#16-анализ-правильности-решения)
- [Задание 2](#задание-2)
  - [2.1 Постановка задачи](#21-постановка-задачи)
  - [2.2 Входные и выходные данные](#22-входные-и-выходные-данные)
  - [2.3 Выбор структуры данных](#23-выбор-структуры-данных)
  - [2.4 Алгоритм](#24-алгоритм)
  - [2.5 Программа](#25-программа)
  - [2.6 Анализ правильности решения](#26-анализ-правильности-решения)
- [Задание 3](#задание-3)
  - [3.1 Постановка задачи](#31-постановка-задачи)
  - [3.2 Входные и выходные данные](#32-входные-и-выходные-данные)
  - [3.3 Выбор структуры данных](#33-выбор-структуры-данных)
  - [3.4 Алгоритм](#34-алгоритм)
  - [3.5 Программа](#35-программа)
  - [3.6 Анализ правильности решения](#36-анализ-правильности-решения)
- [Задание 4](#задание-4)
  - [4.1 Постановка задачи](#41-постановка-задачи)
  - [4.2 Входные и выходные данные](#42-входные-и-выходные-данные)
  - [4.3 Выбор структуры данных](#43-выбор-структуры-данных)
  - [4.4 Алгоритм](#44-алгоритм)
  - [4.5 Программа](#45-программа)
  - [4.6 Анализ правильности решения](#46-анализ-правильности-решения)


---

### Задание 1

#### 1.1 Постановка задачи
> Программа получает на вход 2 целых числа: начальное значение `a` и количество элементов `n`. Нужно вывести `n` элементов, элемент это сумма квадратов цифр предыдущего числа (для первого числа преодыдущее - это `a`).

#### 1.2 Входные и выходные данные
**Входные данные:**
`a` - Целое число (нулевой член), `n` - Натуральное, 0 < n < 2 147 483 647 (число следующих членов).

**Выходные данные:**
Последовательность из `n` целых чисел

#### 1.3 Выбор структуры данных
Программа получает 2 числа `a`, `n`. Также в программе присутствет переменная для хранения нынешнего элемента последовательности `x` - `int`, переменная счетчика цикла `i` - `int` и переменная суммы квадратов цифр числа `sum` - `int`.

|             | название переменной | Тип (в Java) | 
|-------------|---------------------|--------------|
| (нулевой член)  | `a`                 | `int`     |
| (число следующих членов)  | `n`                 | `int`     | 
| (нынешний элемент последовательности)  | `x`                 | `int`     |
| (счетчик цикла) | `i`                 | `int`     | 
| (сумма квадратов цифр числа) | `sum`                 | `int`     | 

#### 1.4 Алгоритм   
1. Программа получает начальное значение `a` и количество элементов `n`.
2. Если `a < 0`, то значение в переменной `x` умножается на (-1), чтобы стать положительным. Иначе `x` становится равным `a`.
3. `n` раз проходим по алгоритмам снизу:
  - Ввести сумму `sum` = 0.
  - Пока `x` > 0:
    - Добавить к сумме квадрат последней цифры: `sum += (x%10) * (x%10)`
    - Удалить последнюю цифру: `x /= 10`
  - Присвоить `x` = `sum`
- Вывести элемент `x`
  
#### 1.5 Программа
```java
import java.io.PrintStream;
import java.util.Scanner;
import java.io.IOException;

public class Main {
    public static Scanner in = new Scanner(System.in);
    public static PrintStream out = System.out;

    public static void main(String[] args) throws IOException {
        int a = in.nextInt();
        int n = in.nextInt();
        int x;

        if (a < 0){
            x = (-1) * a;
        }
        else{
            x = a;
        }



        for (int i = 0; i < n;i++){

            int sum = 0;

            while(x > 0){
                sum += (x%10) * (x%10);
                x /= 10;
            }


            x = sum;
            out.print(x + " ");
        }
    }
}
```

#### 1.6 Анализ правильности решения
Тест на обычные положительные числа:

Input: 16 10

Output:

37 58 89 145 42 20 4 16 37 58 

Input: 0 10

Output:

0 0 0 0 0 0 0 0 0 0 

Input: -9 10

Output:

81 65 61 37 58 89 145 42 20 4 

Input: 5 0

Output:

### Задание 2
2.1 Постановка задачи
Среди натуральных чисел, не превышающих 10^7, найдите количество чисел, соответствующих маске "?*1*?", которые являются палиндромами (читаются одинаково слева направо и справа налево).
"?" заменяет ровно одну любую цифру
"*" заменяет последовательность цифр любой длины (включая пустую последовательность)

### 2.2 Входные и выходные данные
**Входные данные:**
Входных данных нет

**Выходные данные:**
Целое число - количество чиссел, удволетворяющих условию.

### 2.3 Выбор структуры данных
Используем переменную `count` типа `int` - счетчик чисел, удволетворяющих условию, переменную `s` - `String` - которая хранит в себе число `i` в строковом формате,   переменные счетчика цикла `i` и `j` - `int`, переменну. `revers` - `boolean` - флаг для проверки палиндрома.

|             | название переменной | Тип (в Java) | 
|-------------|---------------------|--------------|
| (счетчик чисел)  | `count`                 | `int`     |
| (счетчик цикла) | `j`                 | `int`     |
| (счетчик цикла) | `i`                 | `int`     | 
| (`i` в строковом формате)  | `s`                 | `String`     | 
| (флаг для проверки палиндрома) | `revers`                 | `boolean`     |

### 2.4 Алгоритм
1. Ввести счетчик `count` = 0.
2. 10^7  раз проходим по циклу:
  - Вводим переменную `s` типа `String` и кладем туда строковое значение `i`.
  - Вводим переменную `revers` типа `boolean` для проверки на палиндром.
  - Проходимся от первого элемента строки, до сеедины"
    -Проверяем, если элемент под индексом `j` не равняется элементу под индексу s.length() -1 -j (зеркальный, -1, так как мы идем с 0).
      -То `revers` = `false`. (условие не выполнено)
  - Если условие на палиндром выполнено и симовл по середине числа = `1` и количество элементов в строке не четно и длина строки больше 2:
    - `count` увеличивается на 1.
- Вывести счетчик `count`.

### 2.5 Программа
```java
import java.io.PrintStream;
import java.util.Scanner;
import java.io.IOException;

public class Main {
    public static Scanner in = new Scanner(System.in);
    public static PrintStream out = System.out;

    public static void main(String[] args) throws IOException {

        int count = 0;

        for (int i = 0; i <= 10000000; i++) {
            String s = Integer.toString(i);
            boolean revers = true;
            for (int j = 0;j < s.length()/2; j++ ){
                if(s.charAt(j) != s.charAt(s.length() -1 -j)){
                    revers = false;
                }
            }
            if (revers && s.length() > 2 && s.length() % 2 == 1 && s.charAt(s.length()/2) == '1'){
                count++;
            }
        }
        out.println(count);
    }
}
```
### 2.6 Анализ правильности решения
Тест на числах от 1 до 1000: 
Output: 9

И вправду: (111, 121, 131, 141, 151, 161, 171, 181, 191) - 9 чисел.
### Задание 3
### 3.1 Постановка задачи
Нужно найти суммарную длительность всех сессий. Новая сессия начинается с символа 0(login), во время этой сессии могут выполнятся действия - 1(req), у которых есть длительность, а выход из сессии это 2(logout). Если вне сессии (до ее начала или после ее конца) выполняются 1 или 2, то мы их не учитываем.

### 3.2 Входные и выходные данные
Первая строка: число T
Каждая следующая строка: последовательность пар t e, где t – время события, e – его тип (0 = login, 1 = req, 2 = logout); последняя пара имеет ei = -1 и не обрабатывается. 

### 3.3 Выбор структуры данных
Переменная `T` - `int` (максимальное количество секунд для суммы активных сессий), `t` – `int` (время события), `e` – `int` (тип события), `act` - `boolean`(Флаг есть ли сейчас активный сеанс) `flag` - `boolean` (Флаг, который проверяет не введено ли действие, которое заканчивает цикл)  `first` - `int` (первое время в сесии) `last` - `int` (последнее время в сессии) `sum` - `int` (суммарное количество секунд активных сесиий).

### 3.4 Алгоритм
1. Вводим значение `T`
2. Создаем переменные `first` - `int`, `last` - `int`, `sum` - `int`, `t` – `int`, `e` – `int`.
3. Пока не будет введена команда заканчивающая сессию:
   - Вводим переменные `t` – `int` и `e` – `int`.
   - Если сессия активна, проверяем ее на то, превысила ли сумма времени сессий, максимально допустимого значения, если да, то:
    - Вычисляем сумму времени в этой сессии.
    - делаем флаг активности сесии = `false`.
  - Проверяем введен ли символ -1(последняя пара), если да, то:
    - вычисляем сумму времени в сесии.
    - делаем флаг активности сесии = `false`.
  - Если не введен -1:
    - Если введен 0(login), и сессия активна, то суммируем время, если сессия не активна, то задаем значения первого и последнего временного значения в сессии.
    - Если введен 1(req), если сессия активна, то меняем последнее временное значение.
    - Если введен 2(logout), если сессия активна, то прибавляем время сесии к общей сумме. и делаем флаг активности = `false`.
  - Выводим общую сумму `sum`.

### 3.5 Программа
```java
import javax.xml.stream.FactoryConfigurationError;
import java.io.PrintStream;
import java.util.Scanner;
import java.io.IOException;

public class Main {
    public static Scanner in = new Scanner(System.in);
    public static PrintStream out = System.out;

    public static void main(String[] args) throws IOException {

        int T = in.nextInt();

        boolean act = false;
        boolean flag = false;
        int first = 0;
        int last = 0;
        int sum = 0;
        int t;
        int e;

        while (flag == false) {

            t = in.nextInt();
            e = in.nextInt();


            if (act) {
                if (t - last >= T) {
                    sum += last - first;
                    act = false;
                }

            }

            if (e == -1) {
                if (act) {
                    sum += last - first;

                    act = false;
                }
                flag = true;
            }

            if (flag == false) {

                if (e == 0) {
                    if (act) {
                        sum += last - first;
                    }
                    act = true;

                    first = t;
                    last = t;
                }

                if (e == 1) {

                    if (act) {
                        last = t;
                    }
                }

                if (e == 2) {

                    if (act) {
                        last = t;
                        sum += last - first;
                        act = false;

                    }
                }
            }
        }


        out.println(sum);
    }

}
```
### 3.6 Анализ правильности решения
1. logout
Input:
10
0 0
5 1
10 2
15 -1
Output: 10

2. Несколько сессий подряд
Input:
5
0 0
3 2
10 0
15 2
20 -1
Output: 7

3. T
Input:
5
0 0
3 1
15 1
20 -1
Output: 3

4. Вне сессии
Input:
10
5 1
10 2
20 0
30 2
40 -1
Output: 10


### Задание 4
### 4.1 Постановка задачи
Нужно в заданном массиве чисел найти такие, что они встречаются столько же раз, сколько равен их модуль, если таких чисел нет, то выввести `NO`.
### 4.2 Входные и выходные данные
На вход программа получает число `n` - Количество чисел, а затем получает все эти числа, значение которых находиться в диапазоне от -50 до 50.
Программа выводит числовые значение чисел, удволетворяющих условию, если такие есть, а если таких нет, то выводится `NO`.

### 4.3 Выбор структуры данных
Переменная `n` - `int` (количество числе в массиве), `n1` – `int` (числа в массиве), `flag` - `boolean` (Флаг, который проверяет удволетворяет ли число условиям)  `i` - `int` (счетчик цикла),  `a` - `array` (массив где лежал числа n1).
### 4.4 Алгоритм
Так как у нас числа находятся  диапазоне от -50 до 50, то будем записывать их в массив с индексами = их числовому значению + 50. Это нам нужно для того, чтобы в будущем обращатся к этим элементам по индексу в массиве, который не может быть < 0.
1. Создаем переменную `flag` = `false`, вводим значение для `n` и создаем массив `a` из 101 элемента.
2. Проходим по циклу `n` раз.
   - Вводим числа `n1`.
   - Увеличиваем элемент массива с индексом `n1+50` на еденицу (так для каждого отдельного числа у нас будет его количество).
3. Проходим по циклу `101` раз.
   - Если количество добавлений числа != 0 (это условие создано для числа `0`, потому что модуль его = `0`, то есть может возникнуть ошибка) и количество этого числа в массиве = его модулю, то:
       - `flag` = `true`, так как нашлось такое число.
       - Это число выводиться на экран (так как мы проходимся по индексам, то чтобы получилось числовое значение, нужно индекс уменьшить обратно на 50).
4. Если чисел удволетворяющих условию не нашлось, то:
   - Выводим на экран `NO`.
  

### 4.5 Программа
```java
import java.io.PrintStream;
import java.util.Scanner;
import java.io.IOException;
import java.util.TreeMap;

public class Main {
    public static Scanner in = new Scanner(System.in);
    public static PrintStream out = System.out;

    public static void main(String[] args) throws IOException {


        boolean flag = false;
        int n = in.nextInt();

        int[] a = new int[101];

        for (int i = 0; i < n; i++){
            int n1 = in.nextInt();
            a[n1+50] ++;

        }
        for(int i = 0; i < 101; i++){
            if(a[i] != 0 && a[i] == Math.abs((i - 50))){
                flag = true;
                out.print((i-50)+ " ");
            }
        }

        if (flag == false){
            out.print("NO");
        }
    }
}
```
### 4.6 Анализ правильности решения
1. 
Input:
5
1 2 2 3 3
Output: 1 2

2. 
Input:
6
-3 -3 -3 3 3 3
Output: 3 -3

3. 
Input:
4
1 1 2 2
Output: 2

4. 
Input:
3
10 10 10
Output: NO
